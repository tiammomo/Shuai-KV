#pragma once
#include <atomic>
#include <condition_variable>
#include <functional>
#include <memory>
#include <mutex>
#include <queue>
#include <string>
#include <string_view>
#include <thread>
#include <vector>

#include "shuaikv/lsm/manifest.hpp"
#include "shuaikv/lsm/memtable.hpp"
#include "shuaikv/lsm/sst.hpp"
#include "shuaikv/lsm/block_cache.hpp"
#include "shuaikv/pool/thread_pool.hpp"
#include "shuaikv/utils/lock.hpp"

namespace shuaikv {

/**
 * @brief DB 配置
 */
struct DBConfig {
    /// @brief 压缩配置
    lsm::CompressionConfig compression;

    /// @brief Block Cache 配置
    lsm::BlockCache::Config block_cache;

    /// @brief MemTable 最大大小: 3MB (小于页面大小以优化IO)
    size_t memtable_max_size = 4096 * 1024 - 1024 * 1024;

    /// @brief 是否启用 Block Cache
    bool enable_block_cache = true;
};

class DB {
public:
    DB(const DBConfig& config = DBConfig()) : config_(config) {
        memtable_ = std::make_shared<lsm::MemTable>();
        to_sst_thread_ = std::thread(&DB::ToSSTLoop, this);
        manifest_queue_.emplace_back(std::make_shared<lsm::Manifest>());
        sst_id_ = manifest_queue_.back()->max_sst_id();

        // 初始化 Block Cache
        if (config_.enable_block_cache) {
            block_cache_ = std::make_unique<lsm::BlockCache>(config_.block_cache);
        }
    }

    ~DB() {
        {
            shuaikv::common::RWLock::WriteLock w_lock(memtable_lock_);
            if (memtable_->size() > 0) {
                inmemtables_.emplace_back(memtable_);
            }
        }
        {
            std::unique_lock<std::mutex> lock(to_sst_mutex_);
            to_sst_stop_flag_ = true;
            to_sst_cv_.notify_all();
        }
        if (to_sst_thread_.joinable()) {
            to_sst_thread_.join();
        }
        {
            shuaikv::common::RWLock::WriteLock w_lock(manifest_lock_);
            manifest_queue_.back()->Save();
        }
    }

    bool Get(std::string_view key, std::string& value) {
        {
            shuaikv::common::RWLock::ReadLock r_lock(memtable_lock_);
            if (memtable_->Get(key, value)) {
                return true;
            }
            for (auto it = inmemtables_.rbegin(); it != inmemtables_.rend(); ++it) {
                if ((*it)->Get(key, value)) {
                    return true;
                }
            }
        }
        {
            shuaikv::common::RWLock::ReadLock r_lock(manifest_lock_);
            return manifest_queue_.back()->Get(key, value);
        }
        return false;
    }

    void Put(std::string_view key, std::string_view value) {
        memtable_->Put(key, value);
        if (memtable_->binary_size() > config_.memtable_max_size) {
            shuaikv::common::RWLock::WriteLock w_lock(memtable_lock_);
            inmemtables_.emplace_back(memtable_);
            memtable_ = std::make_shared<shuaikv::lsm::MemeTable>();
            // 唤醒刷盘线程
            to_sst_cv_.notify_one();
        }
    }

    /// @brief 获取压缩率统计
    double GetCompressionRatio() const {
        shuaikv::common::RWLock::ReadLock r_lock(manifest_lock_);
        size_t total_size = 0, uncompressed_size = 0;
        for (auto& manifest : manifest_queue_) {
            for (size_t i = 0; i < manifest->levels().size(); ++i) {
                for (auto& sst : manifest->levels()[i].ssts()) {
                    total_size += sst->binary_size();
                    if (uncompressed_size == 0) {
                        // 估算未压缩大小
                        uncompressed_size += sst->binary_size() * 2;  // 假设压缩比 2x
                    }
                }
            }
        }
        return total_size > 0 ? static_cast<double>(total_size) / uncompressed_size : 1.0;
    }
private:
    void ToSSTLoop() {
        while (true) {
            std::unique_lock<std::mutex> lock(to_sst_mutex_);
            // 等待直到有数据需要刷盘或收到停止信号
            to_sst_cv_.wait(lock, [this] {
                return to_sst_stop_flag_ || !inmemtables_.empty();
            });
            if (to_sst_stop_flag_ && inmemtables_.empty()) {
                break;
            }
            // 处理所有待刷盘的 memtable
            while (!inmemtables_.empty()) {
                auto memtable = inmemtables_.front();
                inmemtables_.erase(inmemtables_.begin());
                lock.unlock();  // 释放锁以避免阻塞 Put 操作
                ToSST(memtable);
                lock.lock();    // 重新获取锁
            }
        }
    }

    // 将 memtable 刷盘为 SST 文件（支持压缩和缓存）
    void ToSST(std::shared_ptr<lsm::MemeTable> inmemtable) {
        auto sst = std::make_shared<lsm::SST>(*inmemtable, ++sst_id_, config_.compression);

        // 设置 Block Cache
        if (block_cache_) {
            sst->SetBlockCache(block_cache_.get());
        }

        {
            shuaikv::common::RWLock::WriteLock w_lock(manifest_lock_);
            auto new_manifest = manifest_queue_.back()->InsertAndUpdate(sst);
            if (new_manifest->CanDoCompaction()) {
                new_manifest->SizeTieredCompaction(++sst_id_);
            }
            manifest_queue_.emplace_back(new_manifest);
        }
    }

    // ============ 缓存相关接口 ============

    /// @brief 获取 Block Cache 统计信息
    const lsm::BlockCache::Stats& GetCacheStats() const {
        static lsm::BlockCache::Stats empty_stats;
        return block_cache_ ? block_cache_->GetStats() : empty_stats;
    }

    /// @brief 获取缓存命中率
    double GetCacheHitRate() const {
        return block_cache_ ? block_cache_->GetStats().HitRate() : 0.0;
    }

    /// @brief 清空 Block Cache
    void ClearCache() {
        if (block_cache_) {
            block_cache_->Clear();
        }
    }

    /// @brief 获取当前缓存大小
    size_t GetCacheSize() const {
        return block_cache_ ? block_cache_->CurrentSize() : 0;
    }

private:
    DBConfig config_;  ///< 数据库配置
    std::shared_ptr<lsm::MemTable> memtable_;
    std::vector<std::shared_ptr<lsm::MemTable> > inmemtables_;
    std::vector<std::shared_ptr<shuaikv::lsm::Manifest> > manifest_queue_;
    mutable shuaikv::common::RWLock manifest_lock_;
    shuaikv::common::RWLock memtable_lock_;

    std::unique_ptr<lsm::BlockCache> block_cache_;  ///< Block Cache

    std::thread to_sst_thread_;
    std::mutex to_sst_mutex_;
    std::condition_variable to_sst_cv_;
    bool to_sst_stop_flag_ = false;

    std::atomic_size_t sst_id_{0};
};

}